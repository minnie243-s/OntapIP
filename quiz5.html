<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ôn tập IP (Routing - ICMP - IP)</title>
    <style>
        /* --- GIỮ NGUYÊN CSS CŨ CỦA BẠN --- */
        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --success: #22c55e;
            --error: #ef4444;
            --bg: #f1f5f9;
            --card-bg: #ffffff;
            --text: #334155;
            --selected-bg: #eff6ff;
            --selected-border: #2563eb;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .container {
            background-color: var(--card-bg);
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
            max-width: 800px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: var(--primary);
            color: white;
            padding: 1.5rem 2rem;
        }

        .header h1 { margin: 0; font-size: 1.5rem; }
        
        .progress-bar {
            height: 6px;
            background-color: rgba(255,255,255,0.3);
            margin-top: 1rem;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #fbbf24;
            width: 0%;
            transition: width 0.3s ease;
        }

        .quiz-body { padding: 2rem; }

        .question-meta {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #64748b;
            margin-bottom: 0.5rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .question-text {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .question-image-container {
            text-align: center;
            margin-bottom: 1.5rem;
            display: none; 
        }

        .question-image-container img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .options-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option-item {
            display: flex;
            align-items: flex-start;
            background-color: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .option-item:hover:not(.disabled) {
            background-color: #f8fafc;
            border-color: var(--primary);
        }

        .option-item.selected {
            border-color: var(--selected-border);
            background-color: var(--selected-bg);
        }

        .indicator {
            width: 20px;
            height: 20px;
            border: 2px solid #cbd5e1;
            margin-right: 15px;
            margin-top: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            background: white;
        }

        .type-single .indicator { border-radius: 50%; }
        .type-single .option-item.selected .indicator {
            border-color: var(--primary);
            background-color: var(--primary);
            box-shadow: inset 0 0 0 4px white;
        }

        .type-multi .indicator { border-radius: 4px; }
        .type-multi .option-item.selected .indicator {
            border-color: var(--primary);
            background-color: var(--primary);
            color: white;
        }
        .type-multi .option-item.selected .indicator::after {
            content: '✓'; font-size: 14px; font-weight: bold;
        }

        .option-item.correct {
            background-color: #dcfce7 !important;
            border-color: var(--success) !important;
            color: #15803d !important;
        }
        .option-item.wrong {
            background-color: #fee2e2 !important;
            border-color: var(--error) !important;
            color: #b91c1c !important;
        }
        .option-item.missed {
            border-color: var(--success) !important;
            border-style: dashed;
            background-color: #f0fdf4 !important;
        }
        
        .option-item.disabled { pointer-events: none; opacity: 0.9; }

        .explanation {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #eff6ff;
            border-left: 4px solid var(--primary);
            border-radius: 4px;
            display: none;
            animation: fadeIn 0.5s;
        }

        .controls {
            padding: 1.5rem 2rem;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: flex-end;
            background-color: #f8fafc;
        }

        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn:hover { background-color: var(--primary-dark); }
        .btn:disabled { background-color: #94a3b8; cursor: not-allowed; }

        .hide { display: none !important; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .score-container { text-align: center; padding: 3rem; }
        .score-circle {
            width: 120px; height: 120px; border-radius: 50%;
            background: var(--primary); color: white;
            display: flex; justify-content: center; align-items: center;
            font-size: 2.5rem; font-weight: bold; margin: 0 auto 1.5rem;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header" id="header">
        <h1>Bài tập IP</h1>
        <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
    </div>

    <div class="quiz-body" id="quiz-area">
        <div class="question-meta">
            <span id="q-number">Câu hỏi 1</span>
            <span id="q-type" style="color: var(--primary)">Chọn 1 đáp án</span>
        </div>
        
        <div class="question-text" id="q-text">Loading...</div>
        
        <div class="question-image-container" id="q-img-container">
            <img id="q-img" src="" alt="Hình minh họa">
        </div>

        <div class="options-grid" id="options-grid"></div>
        <div class="explanation" id="explanation"></div>
    </div>

    <div class="score-container hide" id="score-area">
        <div class="score-circle" id="final-score">0</div>
        <h2>Hoàn thành bài thi!</h2>
        <p id="score-msg">...</p>
        <button class="btn" id="restart-btn">Làm lại</button>
    </div>

    <div class="controls" id="controls">
        <button class="btn" id="submit-btn" disabled>Kiểm tra</button>
        <button class="btn hide" id="next-btn">Câu tiếp theo</button>
    </div>
</div>

<script>
    // --- DỮ LIỆU CÂU HỎI ---
const quizData = [

/* ================= KIẾN TRÚC BGP ================= */

{
    question: "Nhận định sau đúng hay sai? Trong kiến trúc kết nối BGP, các router láng giềng eBGP kết nối trực tiếp, còn các router iBGP có thể kết nối không trực tiếp.",
    options: ["Đúng", "Sai"],
    correct: 0,
    note: "eBGP yêu cầu kết nối trực tiếp, iBGP có thể không trực tiếp nhưng phải full-mesh hoặc dùng RR."
},

{
    question: "Khi lựa chọn đường đi theo quy tắc policy, ưu tiên nào được các router BGP áp dụng theo mặc định?",
    options: [
        "AS path, local preference, multi-exit discriminator",
        "Multi-exit discriminator, AS path, local preference",
        "Local preference, AS path, multi-exit discriminator",
        "AS path, multi-exit discriminator, local preference",
        "Tất cả đều sai"
    ],
    correct: 2,
    note: "Thứ tự ưu tiên mặc định: Local Preference → AS Path → MED."
},

/* ================= PHÂN TÍCH BẢNG BGP ================= */

{
    question: "Next hop cho prefix 172.16.0.0/16 trong routing table là gì?",
    hasImage: true,
    imgSrc: "images/5.1.jpg",
    options: [
        "11.0.0.0",
        "192.168.1.2",
        "192.168.4.2",
        "10.0.0.0",
        "Không xác định được"
    ],
    correct: 1,
    note: "Next hop được lấy từ tuyến BGP được chọn đưa xuống routing table."
},

{
    question: "Tương tự như RIP, quá trình loan báo thông tin một prefix bằng các thông điệp BGP cho phép xác định đường định tuyến đến network này qua các AS bằng cách đi ngược lại đường loan báo thông điệp BGP. Như vậy có thể khẳng định đường routing từ một router đến một prefix chính là bằng đường đi qua các router BGP ngược theo thứ tự thông điệp BGP đã đi qua?",
    options: ["Đúng", "Sai"],
    correct: 1,
    note: "BGP không suy ra đường đi vật lý, chỉ dựa trên AS-PATH."
},

/* ================= XỬ LÝ iBGP / eBGP ================= */

{
    question: "Khi nhận được một thông điệp iBGP chứa thông tin một prefix, router BGP thực hiện các hoạt động nào sau đây?",
    options: [
        "Ghi nhận nội dung và quảng bá prefix này đến router láng giềng tiếp theo",
        "Cập nhật AS path cho prefix vừa nhận",
        "Kích hoạt thông tin prefix vừa nhận vào hệ thống IGP của AS",
        "Không làm gì"
    ],
    correct: 0,
    note: "iBGP không sửa AS-PATH, chỉ lan truyền theo quy tắc iBGP."
},

{
    question: "Thông tin nào giúp một router BGP quyết định loan báo thông điệp BGP đến router láng giềng bằng iBGP hay eBGP?",
    options: [
        "Dựa vào địa chỉ IP láng giềng",
        "Dựa vào số hiệu cổng kết nối",
        "Dựa vào AS number khi khai báo router BGP láng giềng",
        "Dựa vào kết nối IGP giữa các router"
    ],
    correct: 2,
    note: "So sánh AS number để phân biệt iBGP hay eBGP."
},

/* ================= REDISTRIBUTE & EXPORT ================= */

{
    question: "Bảng routing của một router BGP có thể được tính toán lại và cập nhật trong các trường hợp nào?",
    options: [
        "Nhận được bản ghi iBGP",
        "Nhận được bản ghi eBGP",
        "Nhận được bản ghi IGP",
        "Tất cả các trường hợp trên"
    ],
    correct: [1, 2],
    note: "Mọi thay đổi đầu vào control plane đều có thể kích hoạt tính toán lại."
},

{
    question: "Quá trình phát hiện và kết nối láng giềng của các router BGP được thực hiện như thế nào?",
    options: [
        "Admin phải khai báo địa chỉ IP của từng router láng giềng",
        "Bằng giao thức ICMP",
        "Bằng giao thức BGP",
        "Không có phương án nào đúng"
    ],
    correct: 0,
    note: "BGP không tự discovery, phải cấu hình thủ công neighbor."
},

{
    question: "Các router BGP sẽ loan báo thông tin prefix nào?",
    hasImage: true,
    imgSrc: "images/5.2.jpg",
    options: [
        "10.0.0.0/8",
        "11.0.0.0/8",
        "172.16.0.0/24",
        "192.168.3.0/24",
        "192.168.41.0/24",
        "192.168.42.0/24"
    ],
    correct: [2, 3, 4],
    note: "Chỉ prefix được export hoặc redistribute phù hợp mới được quảng bá."
},

{
    question: "Trong cấu hình BGP với redistribute OSPF (có hình ảnh), các router BGP sẽ loan báo thông tin prefix nào?",
    hasImage: true,
    imgSrc: "images/5.3.jpg",
    options: [
        "10.0.0.0/8",
        "11.0.0.0/8",
        "172.16.0.0/24",
        "192.168.3.0/24",
        "192.168.41.0/24",
        "192.168.42.0/24"
    ],
    correct: [2, 5],
    note: "Chỉ prefix học từ OSPF được redistribute."
},

/* ================= BGP & INTERNET ================= */

{
    question: "Trong kết nối backbone Internet với BGP, ISP cấp block 221.30.48.0–221.30.63.255 và cấp lại cho My backbone block 221.30.48.0–221.30.50.255. Những prefix nào được quảng bá lên BGP?",
    hasImage: true,
    imgSrc: "images/5.4.jpg",
    options: [
        "3 block /24",
        "1 block /23 và 1 block /24",
        "1 block /22",
        "1 block /20",
        "1 block /19",
        "Không có đáp án đúng"
    ],
    correct: [1, 3],
    note: "221.30.48.0–50.255 = /23 + /24."
},

/* ================= REDISTRIBUTE STATIC ================= */

{
    question: "các router BGP sẽ loan báo thông tin prefix nào?",
    hasImage: true,
    imgSrc: "images/5.5.jpg",
    options: [
        "10.0.0.0/8",
        "11.0.0.0/8",
        "172.16.0.0/24",
        "192.168.3.0/24",
        "192.168.41.0/24",
        "192.168.42.0/24"
    ],
    correct: [1, 2],
    note: "Static route được redistribute vào BGP."
},

{
    question: "Dữ liệu BGP table như sau (có hình ảnh). Next hop của prefix 172.16.0.0/16 trong routing table là gì?",
    hasImage: true,
    imgSrc: "images/5.6.jpg",
    options: [
        "10.0.0.0",
        "192.168.1.2",
        "192.168.4.2",
        "11.0.0.0",
        "Không xác định được"
    ],
    correct: 2,
    note: "Next hop lấy theo bản ghi BGP được chọn."
},

/* ================= XỬ LÝ eBGP ================= */

{
    question: "Khi nhận được một bản ghi eBGP, router sẽ thực hiện những công việc nào sau đây?",
    options: [
        "Cập nhật AS Path",
        "Chuyển tiếp thông tin cho router BGP láng giềng",
        "Lan truyền thông tin prefix từ BGP vào nội bộ AS bằng IGP",
        "Tính toán đường đi theo distance vector hoặc Dijkstra"
    ],
    correct: [0, 1, 2],
    note: "BGP không dùng Dijkstra hay distance vector."
},

/* ================= QUY MÔ ROUTING ================= */

{
    question: "Một router R kết nối Internet backbone (89000 prefix) qua 2 ISP, peering thêm 9000 prefix, và có 5000 prefix nội bộ OSPF. Số route trong control plane của R là bao nhiêu?",
    hasImage: true,
    imgSrc: "images/5.7.jpg",
    options: ["178000", "187000", "192000", "103000"],
    correct: 2,
    note: "89000×2 + 9000 + 5000 = 192000."
},

{
    question: "Dữ liệu các đường đi từ control plan trong router R được lựa chọn và quyết định đưa xuống data plan. Hãy tính số đường đi trong data plan (routing table) của R?",
    hasImage: true,
    imgSrc: "images/5.7.jpg",
    options: ["192000", "178000", "103000", "89000"],
    correct: 2,
    note: "Chỉ giữ best path: 89000 + 9000 + 5000 = 103000."
}

];



    let currentQ = 0;
    let score = 0;
    let selectedAnswers = null; 

    const qNum = document.getElementById('q-number');
    const qType = document.getElementById('q-type');
    const qText = document.getElementById('q-text');
    const imgContainer = document.getElementById('q-img-container');
    const imgEl = document.getElementById('q-img');
    const optionsGrid = document.getElementById('options-grid');
    const explanationEl = document.getElementById('explanation');
    const submitBtn = document.getElementById('submit-btn');
    const nextBtn = document.getElementById('next-btn');
    const progressFill = document.getElementById('progress-fill');
    const restartBtn = document.getElementById('restart-btn');

    // --- 1. HÀM XÁO TRỘN CÂU HỎI (MỚI) ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    // --- 2. HÀM KHỞI TẠO BÀI THI (MỚI) ---
    function initQuiz() {
        shuffleArray(quizData); // Đảo câu hỏi
        currentQ = 0;
        score = 0;
        
        // Reset giao diện
        document.getElementById('quiz-area').classList.remove('hide');
        document.getElementById('controls').classList.remove('hide');
        document.getElementById('header').classList.remove('hide');
        document.getElementById('score-area').classList.add('hide');

        loadQuestion();
    }

    function loadQuestion() {
        const q = quizData[currentQ];
        const isMulti = Array.isArray(q.correct);

        qNum.innerText = `Câu hỏi ${currentQ + 1} / ${quizData.length}`;
        qType.innerText = isMulti ? '(Chọn nhiều đáp án)' : '(Chọn 1 đáp án)';
        qType.style.color = isMulti ? '#e11d48' : '#2563eb';

        qText.innerText = q.question;
        explanationEl.style.display = 'none';
        
        // Xử lý hình ảnh
        if (q.hasImage) {
            imgContainer.style.display = 'block';
            if (q.imgSrc) {
                imgEl.src = q.imgSrc;
            } else {
                imgEl.src = "https://via.placeholder.com/600x300?text=Chua+co+hinh+anh";
            }
        } else {
            imgContainer.style.display = 'none';
        }

        optionsGrid.innerHTML = '';
        optionsGrid.className = 'options-grid ' + (isMulti ? 'type-multi' : 'type-single');
        
        selectedAnswers = isMulti ? [] : null;
        submitBtn.disabled = true;
        submitBtn.classList.remove('hide');
        nextBtn.classList.add('hide');

        q.options.forEach((opt, idx) => {
            const el = document.createElement('div');
            el.className = 'option-item';
            el.innerHTML = `<div class="indicator"></div><div>${opt}</div>`;
            el.onclick = () => handleSelect(el, idx, isMulti);
            optionsGrid.appendChild(el);
        });

        updateProgress();
    }

    function handleSelect(el, idx, isMulti) {
        if (el.classList.contains('disabled')) return;

        if (isMulti) {
            el.classList.toggle('selected');
            const pos = selectedAnswers.indexOf(idx);
            if (pos === -1) selectedAnswers.push(idx);
            else selectedAnswers.splice(pos, 1);
            selectedAnswers.sort((a, b) => a - b);
            submitBtn.disabled = selectedAnswers.length === 0;
        } else {
            const all = optionsGrid.children;
            for (let child of all) child.classList.remove('selected');
            el.classList.add('selected');
            selectedAnswers = idx;
            submitBtn.disabled = false;
        }
    }

    submitBtn.onclick = () => {
        const q = quizData[currentQ];
        const isMulti = Array.isArray(q.correct);
        const allOpts = optionsGrid.children;
        let isCorrect = false;

        for (let child of allOpts) child.classList.add('disabled');

        if (isMulti) {
            const sortedCorrect = [...q.correct].sort((a, b) => a - b);
            const sortedSelected = [...selectedAnswers].sort((a, b) => a - b);
            isCorrect = JSON.stringify(sortedCorrect) === JSON.stringify(sortedSelected);

            for (let i = 0; i < allOpts.length; i++) {
                if (q.correct.includes(i)) {
                    if (selectedAnswers.includes(i)) allOpts[i].classList.add('correct');
                    else allOpts[i].classList.add('missed');
                } else {
                    if (selectedAnswers.includes(i)) allOpts[i].classList.add('wrong');
                }
            }
        } else {
            isCorrect = (selectedAnswers === q.correct);
            if (isCorrect) {
                allOpts[selectedAnswers].classList.add('correct');
            } else {
                allOpts[selectedAnswers].classList.add('wrong');
                allOpts[q.correct].classList.add('correct');
            }
        }

        if (isCorrect) score++;

        if (q.note) {
            explanationEl.innerHTML = `<strong>Giải thích:</strong> ${q.note}`;
            explanationEl.style.display = 'block';
        }

        submitBtn.classList.add('hide');
        nextBtn.classList.remove('hide');
    };

    nextBtn.onclick = () => {
        currentQ++;
        if (currentQ < quizData.length) loadQuestion();
        else showResult();
    };

    function updateProgress() {
        const pct = (currentQ / quizData.length) * 100;
        progressFill.style.width = `${pct}%`;
    }

    function showResult() {
        document.getElementById('quiz-area').classList.add('hide');
        document.getElementById('controls').classList.add('hide');
        document.getElementById('header').classList.add('hide');
        document.getElementById('score-area').classList.remove('hide');
        
        const finalScoreEl = document.getElementById('final-score');
        finalScoreEl.innerText = `${score}/${quizData.length}`;
        
        const pct = (score / quizData.length) * 100;
        const circle = document.querySelector('.score-circle');
        circle.style.background = `conic-gradient(var(--success) ${pct}%, #e2e8f0 0)`;

        const msg = document.getElementById('score-msg');
        if (pct >= 80) msg.innerText = "Xuất sắc! Bạn nắm rất vững kiến thức.";
        else if (pct >= 50) msg.innerText = "Khá tốt! Hãy ôn lại các câu sai nhé.";
        else msg.innerText = "Cần cố gắng thêm!";
    }

    // --- 3. GÁN SỰ KIỆN CHO NÚT LÀM LẠI ---
    restartBtn.onclick = () => {
        initQuiz();
    };

    // --- BẮT ĐẦU ---
    initQuiz(); // Thay vì gọi loadQuestion(), ta gọi initQuiz()
</script>

</body>
</html>